"""Advent of Code 2023 -- Day 4: Scratchcards.

Reference: https://adventofcode.com/2023/day/4
"""
import dataclasses
import re
from re import Pattern
from typing import ClassVar, Type

from jibaoc import solver


@dataclasses.dataclass
class ScratchCard:
    """A ScratchCard."""

    number: int  # The card number.
    matches: int  # Count of winning numbers.
    count: int = 1  # Number of cards generated by this card.
    offspring: set[int] = dataclasses.field(default_factory=set)  # Cards generated by this card.

    _SCRATCHCARD_RE: ClassVar[Pattern[str]] = re.compile(r"Card\s+(\d+): (.*) \| (.*)")

    @classmethod
    def from_string(cls: Type["ScratchCard"], text: str) -> "ScratchCard":
        """Create and return a ScratchCard instance from a text definition."""
        if (match_ := ScratchCard._SCRATCHCARD_RE.match(text)) is not None:
            card_number, winning_numbers, my_numbers = match_.groups()
            number = int(card_number)
            winners: set[int] = {int(x) for x in winning_numbers.split()}
            mine: set[int] = {int(x) for x in my_numbers.split()}
            matches: int = len(mine & winners)
            return cls(
                number=number,
                matches=matches,
                count=1,
                offspring={number + i + 1 for i in range(matches)},
            )
        raise RuntimeError(text)


class D04(solver.Solver):
    """Solve puzzle for day 4."""

    def __post_init__(self) -> None:
        """Initialize a D04 instance."""
        self._cards: list[ScratchCard] = [
            ScratchCard.from_string(line) for line in self.pi.as_list_of_strings() if line
        ]

    def part_one(self) -> int:
        """Return the total number of points for all scratchcards."""
        return int(sum(2 ** (card.matches - 1) for card in self._cards if card.matches))

    def part_two(self) -> int:
        """Return the total number of scratchcards."""
        card_count: int = 0
        # Remove cards with no offspring, adding their count to any of their parent cards.
        while self._cards:
            for card in self._cards.copy():
                if not card.offspring:
                    card_count += card.count
                    self._cards.remove(card)
                    for parent_card in self._cards:
                        if card.number in parent_card.offspring:
                            parent_card.count += card.count
                            parent_card.offspring.remove(card.number)
        return card_count
